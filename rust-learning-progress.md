# Rust 入门学习笔记

## 当前进度

- [x] 环境搭建
- [x] 项目创建与运行
- [x] println! 宏
- [x] 变量与可变性
- [x] 变量遮蔽（Shadowing）
- [x] 数据类型与类型转换
- [x] 函数
- [x] 控制流（if / else）
- [x] 循环（loop / while / for）
- [x] 所有权（Ownership）
- [x] 借用与引用（& / &mut）
- [x] 函数传参与所有权
- [x] 结构体（Struct）
- [ ] 枚举（Enum）
- [ ] 模式匹配（match）
- [ ] 错误处理（Result / Option）

---

## 工具链

```
rustup    → 管理 Rust 版本的总管
├── rustc → 编译器（把 .rs 翻译成机器码）
└── cargo → 项目管家（日常只跟它打交道）
```

常用命令：

```bash
cargo new xxx        # 创建项目
cargo run            # 编译 + 运行
cargo build          # 只编译不运行
cargo run --release  # 编译优化版本（慢编译，快运行）
```

## 项目结构

```
my-first-project/
├── Cargo.toml    # 项目身份证（名称、版本、依赖）
├── src/
│   └── main.rs   # 代码入口，程序从 fn main() 开始执行
└── target/       # 编译产物（类似前端的 dist/，不提交到 Git）
```

## debug vs release

| | debug | release |
|---|---|---|
| 编译速度 | 快 | 慢 |
| 运行速度 | 慢 | 快（10-100倍） |
| 用途 | 开发调试 | 发布给用户 |

release 快的原因：编译器花时间优化机器指令（消除无用计算、展开循环、内联函数）。

## println! 宏

```rust
println!("模板字符串");           // 无占位符
println!("我叫{}", "小白");       // 一个占位符
println!("{}+{}={}", 1, 2, 3);   // 多个占位符，按顺序填入
```

- `println!` 打印后换行，`print!` 不换行
- `!` 表示这是宏，不是函数，不能省略
- `println`（不带 `!`）在 Rust 中不存在，写了直接报错
- 为什么用宏：普通函数做不到"任意数量、任意类型的参数"，宏在编译时展开，既灵活又安全又零开销

## 变量与可变性

```rust
let score = 60;       // 不可变（默认）
let mut score = 60;   // 可变（需要显式声明）
score = 95;           // 只有 mut 变量才能重新赋值
```

- `mut` = mutable（可变的）的缩写
- Rust 默认不可变，JS 默认可变（设计哲学相反）
- 好处：看到 `let` 就知道不会变，看到 `let mut` 就知道后面会变

## 变量遮蔽（Shadowing）

```rust
let x = 1;        // x_v1
let x = "hello";  // x_v1 死了，x_v2 诞生，类型都可以不同
```

- 每个 `let` 都是一个全新的变量，旧的被彻底替代
- 跟 `mut` 不同：`mut` 是同一个盒子换内容，shadowing 是扔掉旧盒子拿新盒子
- 适合用在：类型转换、逐步清洗数据、用完 mut 后锁死变量
- 注意：只用在"同一条数据的演变"上，不相关的数据不要用同名

## 数据类型

```
整数：  i32    （常用，默认）
浮点数：f64    （常用，默认）
布尔：  bool   （true / false）
字符：  char   （单个字符，用单引号 'A'）
字符串：&str   （文本，用双引号 "你好"）
```

- 不写类型时 Rust 会自动推断，也可以显式标注：`let age: i32 = 18;`
- 不同类型不能直接运算，需要用 `as` 手动转换：`a as f64 + b`
- Rust 没有三等号 `===`，因为不同类型根本不能比较，`==` 就够了

## 函数

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b       // 最后一行不加分号 = 返回值
}
```

- 参数必须标注类型（类似 TypeScript）
- `-> i32` 声明返回值类型
- 最后一行不加分号 = 返回值；也可以用 `return a + b;` 显式返回
- 分号是一个开关：加上 = 丢弃值（语句），不加 = 保留值（表达式）
- 函数只做一件事（单一职责）

## 控制流

```rust
// if / else if / else（不需要括号）
if score >= 90 {
    println!("优秀");
} else if score >= 60 {
    println!("及格");
} else {
    println!("不及格");
}

// if 是表达式，可以赋值
let label = if age >= 18 { "成年" } else { "未成年" };

// 复杂条件用括号分组，提高可读性
if (a && b) || c { ... }
```

- `if` 后面不强制加括号，但条件内部可以用括号分组
- `return` 是从整个函数返回，不能用在 `let =` 赋值的 `if` 表达式里
- 运算符优先级：比较 > `&&` > `||`

## 循环

```rust
// 1. loop —— 无限循环，用 break 跳出，能返回值
let result = loop {
    if count == 10 { break count * 2; }
};

// 2. while —— 条件循环
while count < 5 { ... }

// 3. for —— 遍历循环（最常用）
for i in 0..5 { ... }   // 0..5 = 0,1,2,3,4（不含5）
```

使用频率：`for` 最多，`loop` 常用（服务器、重试场景），`while` 最少。

## 所有权（Ownership）

核心三条规则：
1. 每个值都有一个主人（owner）
2. 同一时刻只能有一个主人
3. 主人离开作用域，值被自动丢弃

```rust
let a = String::from("hello");
let b = a;       // 所有权转移，a 死了
// println!("{}", a);  // 报错！

let c = String::from("hello");
let d = c.clone();  // 克隆一份，c 和 d 各有一份独立的数据
```

- 赋值 = 转移所有权（不是复制）
- `clone()` = 真的复制一份（两份独立数据）
- 栈上的简单类型（i32, bool, f64）会自动复制，不受所有权影响

## 借用与引用

```rust
&x       // 不可变引用：只能看，不能改
&mut x   // 可变引用：能改，但同一时刻只能借给一个人
```

铁律（二选一）：
- 可以有多个 `&`（大家一起看）
- 只能有一个 `&mut`（只能一个人改）
- 两者不能同时存在

借用归还：Rust 看借用者最后一次出现在哪一行，过了那行就自动归还。

- "引用"是语法层面（`&` 这个符号）
- "借用"是语义层面（Rust 对引用施加的规则）
- Rust 的引用 ≠ JS 的引用（JS 的引用没有借用规则）

## 函数传参与所有权

```rust
greet(name)       // 转移所有权，name 死了
greet(&name)      // 不可变借用，name 还活着
greet(&mut name)  // 可变借用，name 还活着，函数内可以修改
```

## 结构体（Struct）—— 学习中

```rust
struct Student {
    name: String,
    age: i32,
    score: f64,
}

impl Student {
    fn introduce(&self) { ... }       // 借来看看
    fn set_score(&mut self, s: f64) { ... }  // 借来改改
}
```

- struct 类似 TS 的 interface + 对象，但是实实在在的数据结构，编译器按它分配内存
- `impl` 块给 struct 加方法（不用 class）
- `&self` = this + 不可变借用，`&mut self` = this + 可变借用
- **mut 是全有或全无**：不能只让某个字段可变，要么整个 struct 可变，要么整个不可变
- 已学：定义 struct、创建实例、访问字段、impl 方法（&self / &mut self）、关联函数（`::` 调用）、结构体字段的所有权
- 关联函数：`impl` 块中没有 `self` 参数的函数，用 `Student::new()` 调用，常用于构造函数
- `new` 不是关键字，是社区约定的构造函数名
- 结构体字段所有权：String 字段可以被单独搬走（`let name = s.name`），i32 等简单类型自动复制
- 便宜的操作（复制 i32）隐式做，贵的操作（复制 String）必须显式 `.clone()`

## 遇到的坑

- **Windows 链接器冲突**：Git 自带的 `link.exe` 被误认为 MSVC 链接器。解决：`rustup default stable-x86_64-pc-windows-gnu`
- **VSCode rust-analyzer 延迟**：编辑器有时显示旧错误，以终端 `cargo run` 结果为准
- **push_str 末尾不加分号碰巧能跑**：不是有意返回值的场景，应该加分号

---

## 学到的计算机哲学

| 思想 | 含义 |
|------|------|
| **约定优于配置** | 代码放哪、入口叫什么，都是约定好的，不需要你配置 |
| **增量编译** | 只重新编译改动的部分，所以第二次编译比第一次快 |
| **源码是唯一的真相** | target/ 是产物，随时可重新生成；src/ 才是要保管的 |
| **默认安全** | 让正确的事容易做，让危险的事显眼（mut 标签） |
| **零成本抽象** | 好用的语法不应该有运行时代价 |
| **抽象的代价** | debug 保留人类思维结构，release 只为机器服务 |
| **显式优于隐式** | 类型转换、可变性都要你明确写出来，不偷偷帮你做 |
| **表达式导向** | Rust 中几乎一切皆表达式，都能产出值。分号是"丢弃值"的开关 |
| **编译器是老师** | Rust 编译器不只报错，还告诉你怎么改，认真读每条信息 |
| **单一职责** | 每个函数只做一件事，修改就只修改，打印交给调用者 |
